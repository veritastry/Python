单例模式：
基于new方式的


基于模块的方式（python仅有的，加载模块值加载一次）

不管导入多少次，模块加载只加载一次
当是相同的内存空间的时候，直接从py中取文件,拿已经执行完的结果，不在重新加载了
不管怎么调用都是一个程序在启动,当执行完后，不管怎么的导入都是一个程序在执行，都是同一个内存空间，（调用相同的模块里面的类的方法）当程序启动的时候，导入模块已经启动了相对应的py文件（包括实例化了里面的类）



当已经实例化了一次之后，就直接从pyc文件中取了
但如果之前没有实例化的话，就是两个不同的实例化文件了





基于模块的单例对象的实现

实例三：





from   test2 import obj,a
m1=obj()
实例化了一次
print(id(m1))


from  test2  import obj,a

m2=obj()
重新实例化了一次

print(id(m2))






test2：

class  obj():
    def foo(self):
        print('ok')



a=obj()
这个a已经是一个单例对象了，当你进行调用的时候，第一次是导入这个单例对象，第二次是从这个pyc文件里面去拿，都是共用的同一个单例对象 所以之后的id是相同的，后面调用都是同一个实例化好的对象，一个空间里面的对象





这两个是不同的结果
讲解：
当第一次执行的时候，test2里面的文件已经被声明了，类也是被实例了一次，pyc文件也生成了，m1是一个实例对象
当下一次执行的时候，不导入了，直接从pyc里面拿出来，m2在实例化一次对象，总之一个类实例化一个对象就是新的一个对象，相当于下面  m2已经重新实例化这个类了




单例对象是已经在原来的文件实例好了，你拿过来就好，这个是同一个文件（同一个单例对象），所以内存空间是一样的，id也一样，当你在自己的文件里面进行实例化的时候，就已经是不同的实例对象，id是不一样的,总之，已经实例好的文件你拿过来使用的时候，已经是一个单例对象，id是一样（除非你重新实例化了一次，那么这个id就是不一样的）







必须单独的在一个文件里面创建一个类，然后在不同的模块里面进行调用这个单例对象，基于模块的单例对象



admin.site.register
这个方法是：
首先导入这个admin的模块进来，导入的过程已经执行了这个admin模块文件
这个admin文件里面导入了site的模块，那么在执行这个admin的文件的时候，也执行这个site的文件，site里面一个site=Adminsite()  后面的这个类里面封装了很多方法，包括里面有register的方法，所以当你执行这个admin.site.register的时候，相当于调用这个site（单例对象）某一个方法





























































